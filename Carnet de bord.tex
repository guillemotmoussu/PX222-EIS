\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage{hyperref}
\usepackage{float}
\usepackage{xcolor}
\usepackage{pgfplots}
\usepackage{asymptote}
\usepackage[european, straightvoltages, RPvoltages]{circuitikz}
\usetikzlibrary{babel}
\usepackage{siunitx}
\usepackage{wrapfig}
\usepackage{multicol} 
\usepackage{ulem}
\usepackage{listings}
\usepackage{schemabloc}
\setlength{\parindent}{0pt}

\title{PROJET EIS - PX222}
\author{Guillemot MOUSSU et Rémi MAZZONE}
\date{2° semestre - 2022-2023}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
language=Python,
aboveskip=3mm,
belowskip=3mm,
showstringspaces=false,
columns=flexible,
basicstyle={\small\ttfamily},
numbers=left,
numberstyle=\tiny\color{gray},
keywordstyle=\color{blue},
commentstyle=\color{dkgreen},
stringstyle=\color{mauve},
breaklines=true,
breakatwhitespace=true,
tabsize=3} 

\begin{document}
\maketitle
\tableofcontents
\listoffigures
\pagebreak

\section{Séance 0 - 21/03/2023}
\subsection{Notes prises au tableau}
\begin{figure} [H]
\begin{center}
\includegraphics[width=0.9\textwidth]{Schémas/Notes tableau séance 0.png} 
\end{center}
\caption{Notes séance 0}
\end{figure}

\subsection{Idées de plan de recherches}
\begin{itemize}
\item \textbf{Caractérisation de la bobine} : mesure de la résistance et l'inductance de la bobine. Cela permettra de modéliser la bobine et de calculer le champ magnétique qu'elle produit
\item \textbf{Modélisation de la bobine} : utilisation des valeurs mesurées pour construire un modèle électrique de la bobine, par exemple en utilisant l'équation de l'inductance d'une bobine. Pour une précision plus élevée, il peut être nécessaire d'inclure d'autres effets tels que la saturation du noyau de la bobine ou la résistance série équivalente
\item \textbf{Étude du champ magnétique de la bobine} : calcul de la distribution du champ magnétique à l'aide d'un logiciel de simulation. Validation des résultats expérimentalement
\item \textbf{Choix d'un capteur de distance} : choix d'un capteur de distance infrarouge adapté à la plage de mesure et à la précision requises. La fréquence de mesure et la plage de mesure peuvent influencer le résultat
\item \textbf{Calibration du capteur de distance} : déterminer la relation entre la tension de sortie du capteur et la distance de la bille par rapport à la bobine
\item \textbf{Conception d'un correcteur } : utiliser les données obtenues précédemment pour concevoir un correcteur proportionnel-intégral-dérivé (PID) ou un correcteur à avance de phase pour contrôler la position de la bille. C'est la partie clé de ce projet. Le correcteur PID est une méthode de contrôle classique qui est souvent utilisée pour les systèmes de positionnement. Un correcteur à avance de phase peut également être utilisé pour améliorer les performances.
\item \textbf{Implémentation du correcteur } : test du correcteur via Matlab et Simulink
\item \textbf{Étalonnage du système} : ajuster les paramètres du correcteur pour atteindre la précision et la stabilité requises
\item \textbf{Validation du système} : tester le système dans différentes conditions et valider ses performances
\item \textbf{Optimisation du système} : améliorer le système en optimisant les paramètres du correcteur et en utilisant des techniques avancées de contrôle, telles que le contrôle prédictif et le contrôle adaptatif
\end{itemize}
\medskip
Il est important de noter que certains des points ont déjà été réalisés lors du premier semestre

\pagebreak
\section{Séance 1 - 05/04/2023}
\subsection{Reprise des éléments du semestre précédent}
Avec Hopkinson, nous avions obtenu un schéma équivalent de la bobine : 
\begin{figure}[H]
\begin{center}
\begin{circuitikz}
\draw
(0,0) to [V=$\varepsilon$] (0,2)
(0,2) to [short, i=$\varphi$] (2,2)
(2,2) to [R, l=$\mathfrak{R}_1$] (2,0)
(2,0) to [short] (0,0)
(2,2) to [R, l=$\mathfrak{R}(z)$, *-] (5,2)
(2,0) to [R, l=$\mathfrak{R}_0$, *-] (5,0)
(5,2) to [short] (5,0);
\end{circuitikz}
\caption{Modélisation de la bobine}
\end{center}
\end{figure}

Nous avions trouvé que la fonction de transfert de la bobine est : $\boxed{T_{BO}=\dfrac{Z}{I}=\dfrac{k_i}{k_z-mp^2}}$\\
Avec les valeurs suivantes :\\
\medskip
$I_0 = 2A$, $Z_0 = 22mm$, $L_1 = 6.73H$, $\alpha = 2.06$, $m = 35.8g$\\
$k_i = \dfrac{I_0 \cdot L_1 \cdot \alpha}{(1 + \alpha \cdot Z_0)^2}$, $k_z = \dfrac{I_0^2 \cdot L_1 \cdot \alpha^2}{(1 + \alpha \cdot Z_0)^3}$

\subsection{Utilisation de Matlab}
\label{Matlab1}
Nous avons donc notre fonction de transfert. Une idée qui nous est venue est d'adapter les scripts pour utiliser l'outil de M. Mendes que nous avons découvert en TP. Cela devrait nous permettre de calculer notre correcteur. Pour commencer, on a placé nos valeurs dans Matlab et tracé le bode obtenu. Cette étape est présente seulement pour nous faire une idée du système à l'heure actuelle

\begin{figure}[H]
Code Matlab que nous avons utilisé :
\begin{lstlisting}[language=Matlab]
I0 = 2;
Z0 = 22 * 10^-3;
L1 = 6.73;
alpha = 2.06;
ki = (I0 * L1 * alpha) / (1 + alpha * Z0) ^2;
kz = -(I0 ^2 * L1 * alpha ^2) / (1 + alpha * Z0) ^3;
m = 35.8;

num =  ki ;
den = [(-m) 0 kz];
sys = tf(num,den);

figure;
bode(sys)
grid on
figure;
nyquist(sys)
grid on
\end{lstlisting}
\end{figure}

\pagebreak
On obtient donc le bode suivant :
\begin{figure} [H]
\begin{center}
\includegraphics[width=0.9\textwidth]{Schémas/Bode initial.png} 
\end{center}
\caption{Bode obtenu}
\label{fig:Bode initial}
\end{figure}

On trace ensuite le diagramme de Nyquist :
\begin{figure} [H]
\begin{center}
\includegraphics[width=0.6\textwidth]{Schémas/Nyquist initial.png} 
\end{center}
\caption{Nyquist obtenu}
\label{fig:Nyquist initial}
\end{figure}

On remarque donc qu'il reste du travail avant d'avoir un résultat satisfaisant, mais nous reviendrons sur ce point ultérieurement

\subsection{Modélisation point par point du système}
\label{Modélisation point par point}
L'objectif est de réaliser un circuit correspondant à ce schéma bloc :

\begin{figure} [H]
\begin{center}
\begin{tikzpicture}
\sbEntree{E}
\sbSumb{comp}{E}                
\sbRelier[$C$]{E}{comp}
\sbBloc{reg}{$R$}{comp}  
\sbRelier[$\varepsilon$]{comp}{reg}
\sbBloc{amp}{$A$}{reg}
\sbRelier[$U$]{reg}{amp}
\sbBloc{sys}{$H$}{amp}      
\sbRelier[$X$]{amp}{sys}
\sbSortie{S}{sys}                
\sbRelier[$Y$]{sys}{S}
\sbDecaleNoeudy[4]{S}{U}
\sbBlocr{cap}{$B$}{U}        
\sbRelieryx{sys-S}{cap}
\sbRelierxy[$Y_m$]{cap}{comp}
\end{tikzpicture}
\end{center}
\caption{Schéma bloc du système}
\label{fig:Schéma bloc}
\end{figure}

\subsubsection{Modélisation de l'amplificateur}
\label{Modélisation ampli}
Nous avons en sortie d'un STM8 un signal de 5V, nous voulons que la bobine soit alimentée en 30V. Pour cela on utilise un amplificateur à AOP, en série avec un transistor bipolaire. On a le schéma classique d'un amplificateur à AOP :

\begin{figure} [H]
\begin{center}
\begin{tikzpicture}
% Schéma bloc
\sbEntree{E}
\sbBloc{amp}{$A$}{E}
\sbRelier[$U$]{E}{amp}
\sbSortie{S}{amp}
\sbRelier[$X$]{amp}{S}

% Flèche entre les deux schémas
\draw[->, thick] (4,0) -- (6,0);

% Schéma elec
\draw (11,0) node[op amp] (opamp) {};
\draw (opamp.-) to[R, l=$R_1$] ++(-2,0) node[ground] {};
\draw (opamp.+) to[short, -*] ++(-0.5,0) node[label=left:$U$] {};
\draw (opamp.-) to[short] ++(0,1) coordinate (feedback);
\draw (feedback) to[R, l=$R_2$] ++(2,0) -| (opamp.out);
\draw (opamp.out) to[short, -o] ++(1,0) node[label=right:$X$] {};
\end{tikzpicture}
\end{center}
\caption{Amplificateur à AOP}
\label{fig:Amplificateur à AOP}
\end{figure}

Si on ajoute le transistor et la bobine au schéma, cela nous donne :
\begin{figure} [H]
\begin{center}
\includegraphics[width=0.6\textwidth]{Schémas/Ampli.png} 
\end{center}
\caption{Modélisation du bloc amplificateur}
\label{fig:Modélisation du bloc amplificateur}
\end{figure}

\subsubsection{Modélisation d'un régulateur PD}
\label{Modélisation PD}
On a le schéma classique d'un régulateur PD :

\begin{figure} [H]
\begin{center}
\begin{tikzpicture}
% Schéma bloc
\sbEntree{E}
\sbBloc{amp}{$R$}{E}
\sbRelier[$\varepsilon$]{E}{amp}
\sbSortie{S}{amp}
\sbRelier[$U$]{amp}{S}

% Flèche entre les deux schémas
\draw[->, thick] (4,0) -- (6,0);

% Schéma elec
\draw (11,0) node[op amp] (opamp) {};
\draw (opamp.-) to[R, l=$R_1$] ++(-2,0) coordinate (entry) {};
\draw (entry) to [short, -o] ++(-0.5,0) node[label=left:$\varepsilon$] {};
\draw (entry) to[short] ++(0,1) coordinate (pointC);
\draw (pointC) to [C, l=$C$] ++(2,0) -| (opamp.-);
\draw (opamp.+) to[short, -] ++(-0.5,0) node[ground] {};
\draw (opamp.-) to[short] ++(0,1) coordinate (feedback);
\draw (feedback) to[R, l=$R_2$] ++(2,0) -| (opamp.out);
\draw (opamp.out) to[short, -o] ++(1,0) node[label=right:$U$] {};
\end{tikzpicture}
\end{center}
\caption{Régulateur PD}
\label{fig:Régulateur PD}
\end{figure}

Si on donne le schéma complet de ce bloc, cela nous donne :

\begin{figure} [H]
\begin{center}
\includegraphics[width=0.5\textwidth]{Schémas/Correcteur PD.png} 
\end{center}
\caption{Modélisation du bloc régulateur (PD)}
\label{fig:Modélisation du bloc régulateur (PD)}
\end{figure}

\subsubsection{Modélisation d'un régulateur PID}
\label{Modélisation PID}
Dans le cas où l'on souhaite finalement modéliser un régulateur PID, on doit ajouter un condensateur en parallèle de notre résistance :

\begin{figure} [H]
\begin{center}
\begin{circuitikz}
\draw (0,0) node[op amp] (opamp) {};
\draw (opamp.-) to[R, l=$R_1$] ++(-2,0) coordinate (entry) {};
\draw (entry) to [short, -o] ++(-0.5,0) node[label=left:$\varepsilon$] {};
\draw (entry) to[short] ++(0,1) coordinate (pointC);
\draw (pointC) to [C, l=$C_1$] ++(2,0) -| (opamp.-);
\draw (opamp.+) to[short, -] ++(-0.5,0) node[ground] {};
\draw (opamp.-) to[short] ++(0,1) coordinate (feedback);
\draw (opamp.-) to[short] ++(0,2.5) coordinate (feedback2);
\draw (feedback) to[R, l=$R_2$] ++(2,0) -| (opamp.out);
\draw (feedback2) to[C, l=$C_2$] ++(2,0) -| (opamp.out);
\draw (opamp.out) to[short, -o] ++(1,0) node[label=right:$U$] {};
\end{circuitikz}
\end{center}
\caption{Régulateur PID}
\label{fig:Régulateur PID}
\end{figure}

\subsubsection{Modélisation du système complet (PD)}
\label{Modélisation complète}
On choisit le régulateur PD pour représenter le système complet. On a vu qu'il suffira d'ajouter une capacité pour passer à un régulateur PID au besoin. On repère bien les blocs comparateur, amplificateur (A), régulateur (R) et capteur (B)

\begin{figure} [H]a	
\begin{center}
\includegraphics[width=1\textwidth]{Schémas/Modèle complet PD.png} 
\end{center}
\caption{Modélisation complète avec retour (PD)}
\label{fig:Modélisation complète avec retour (PD)}
\end{figure}


\subsection{Conclusions pour cette séance}
On commence à avoir des pistes intéressantes. Les schémas que nous avons réalisés vont nous permettre de se faire une idée du système à concevoir, et nous avons perçu l'importance d'utiliser Matlab pour nous aider dans nos calculs

\section{Travail entre les séance 1 et 2}
\subsection{Correction des éléments de la séance précédente}
Nous avions manqué de temps pour terminer comme nous le souhaitions certains points de la séance précédente. Nous avons travaillé sur les points suivants :
\subsubsection{Matlab}
\textit{Pour plus de détails se référer à la section} \ref{Matlab1}\\

Les schémas avaient étés rendus avec Octave, mais après comparaison des rendus, ceux de Matbab donnent d'autres résultats. Les figures \ref{fig:Bode initial} et \ref{fig:Nyquist initial} ont donc été mises à jour

\subsubsection{Modélisation point par point du système}
\textit{Pour plus de détails se référer à la section} \ref{Modélisation point par point}\\

La figure \ref{fig:Schéma bloc} est maintenant rendue en \LaTeX\\

Pour plus de clarté, les points \ref{Modélisation ampli}, \ref{Modélisation PD} et \ref{Modélisation PID} ont été repris. Les figures \ref{fig:Amplificateur à AOP}, \ref{fig:Régulateur PD} et \ref{fig:Régulateur PID} ont été reprises en \LaTeX. Les figures \ref{fig:Modélisation du bloc amplificateur} et \ref{fig:Modélisation du bloc régulateur (PD)} ont été reprises sur Fritzing, avec un bloc AOP mis à jour\\

Le point \ref{Modélisation complète} a été séparé plus plus de clarté. La figure \ref{fig:Modélisation complète avec retour (PD)} y a été ajoutée

\subsection{Simulation de l'amplificateur}
\begin{multicols}{2}
On veut donc simuler notre bloc amplificateur. Dans l'idéal on devrait avoir le graphique suivant :
\begin{figure} [H]
\begin{center}
\includegraphics[width=0.5\textwidth]{Schémas/sim matlab ampli.png} 
\end{center}
\caption{Résulat idéal de la simulation}
\end{figure}

On rentre donc le modèle suivant dans LTSPICE :
\begin{figure} [H]
\begin{center}
\includegraphics[width=0.5\textwidth]{Schémas/ltspice ampli.png} 
\end{center}
\caption{Schéma LTSPICE de l'amplificateur}
\end{figure}
\end{multicols}

Et on obtient le résultat suivant :
\begin{figure} [H]
\begin{center}
\includegraphics[width=1\textwidth]{Schémas/sim ampli.png} 
\end{center}
\caption{Simulation de l'amplificateur}
\end{figure}

\textbf{Remarques} :
\begin{itemize}
\item On a utilisé un AOP quelconque (le LT1001 en l'occurence)
\item On a utilisé les mesures de la bobine du S1 ($R=13.3\Omega$ et $L=0.98H$)
\item On a utilisé un transistor quelconque
\end{itemize}

On remarque que la simulation correspond au modèle théorique voulu. C'est bon signe pour la suite, il reste à le tester avec des composants réels

\pagebreak
\section{Séance 2 - 18/04/2023}
\subsection{Réflexion sur la numérisation du correcteur}
On va donc chercher à numériser la partie correcteur. Cela correspond aux éléments suivants sur notre schéma bloc :
\begin{figure} [H]
\begin{center}
\begin{tikzpicture}
\sbEntree{E}
\sbSumb{comp}{E}                
\sbRelier[$C$]{E}{comp}
\sbStyleBloc{red,very thick}
\sbBloc{reg}{$R$}{comp}  
\sbRelier[$\varepsilon$]{comp}{reg}
\sbStyleBlocDefaut
\sbBloc{amp}{$A$}{reg}
\sbRelier[$U$]{reg}{amp}
\sbBloc{sys}{$H$}{amp}      
\sbRelier[$X$]{amp}{sys}
\sbSortie{S}{sys}                
\sbRelier[$Y$]{sys}{S}
\sbDecaleNoeudy[4]{S}{U}
\sbStyleBloc{red,very thick}
\sbBlocr{cap}{$B$}{U}        
\sbRelieryx{sys-S}{cap}
\sbRelierxy[$Y_m$]{cap}{comp}
\end{tikzpicture}
\end{center}
\caption{Schéma bloc du système, version électronique numérique}
\end{figure}

On utilisera un STM8s pour la numérisation. On compte utiliser un port analog input pour l'entrée venant du capteur, et un port I/O piloté en PWM pour la sortie $U$

\subsection{Prise en main du STM8s}
On a le brochage du STM8 :
\begin{figure} [H]
\begin{center}
\includegraphics[width=0.6\textwidth]{Schémas/Brochage STM8.jpg} 
\end{center}
\caption{Brochage du STM8s discovery}
\end{figure}

On définit pour le moment qu'on utilise le port $B0$ (Analog 0) pour l'entrée et le port $G0$ pour la sortie (I/O classique)

\subsection{Premier essai de code}
Par la suite, nous avons cherché à faire fonctionner la carte, en vue de pouvoir faire nos mesures. On se base sur l'exemple fourni par ST permettant de faire clignoter la LED installée sur la carte : \href {https://www.st.com/en/embedded-software/stsw-stm8023.html}{\color{blue} fichiers du projet}. Ce projet est écrit en C, compilé à l'aide de Cosmic. On confirme que cela fonctionne

\subsection{Essais avec Arduino}
\medskip
Afin de pouvoir communiquer, notemment via la communication série avec la carte, on a essayé d'installer les librairies nécessaires sur l'Arduino IDE. On se base sur le travail de Michael Mayer pour le site \href {https://circuitdigest.com/microcontroller-projects/programming-stm8s-microcontrollers-using-arduino-ide}{\color{blue} CircuitDigest}. Malgré de nombreuses tentatives, nous n'avons pas réussi à compiler un projet et à l'envoyer sur la carte\\

Sur nos PC, nous obtenons l'erreur suivante :
\begin{lstlisting}
Installing platform sduino:stm8@0.5-pre2
Failed to install platform: sduino:stm8.
Error: 13 INTERNAL: Cannot install platform: installing platform sduino:stm8@0.5-pre2: searching package root dir: no unique root dir in archive, found 'C:\Users\guill\AppData\Local\Arduino15\tmp\package-518500940\STM8S_StdPeriph_Driver' and 'C:\Users\guill\AppData\Local\Arduino15\tmp\package-518500940\cores'
\end{lstlisting}

Et sur les PC de l'école, malgré l'installation des drivers, Arduino ne détecte pas la carte dans la liste des ports disponibles

\subsection{Essais avec STVD}
Nous avons en parallèle repris le code d'un précédent TP, où nous devions implémenter la génération de signaux PWM :
\begin{lstlisting}[language={[x86masm]Assembler}]
stm8/
    #include 'mapping.inc'
    #include 'stm8s105c_s.inc'

    segment 'rom'
debut
    bset PD_DDR,#3
    bset PD_CR1,#3
    bres PD_ODR,#3
    mov TIM4_PSCR,#6
    mov TIM4_ARR,#155
    bset TIM4_IER,#0
    bset TIM4_CR1,#0
    rim
    bset ADC_CR1,#0
    mov ADC_CSR,#$00
    bres ADC_CR2,#3

boucle_infinie
    jra boucle_infinie

    interrupt Timer4_ISR
Timer4_ISR
    bres TIM4_SR,#0
    bcpl PD_ODR,#3
    bset ADC_CR1,#0
attente_fin_conversion
    btjf ADC_CSR,#7,attente_fin_conversion
    bres ADC_CSR,#7
    ld A,#1
    or A,ADC_DRH
    ld TIM4_ARR,A
    iret

    segment 'vectit'
    dc.l {$82000000+debut}
    segment at 8064 'vectit'
    dc.l {$82000000+Timer4_ISR}

    end
\end{lstlisting}

Le but de ce code est de réaliser les actions suivantes :
\begin{itemize}
\item Toutes les 10ms, une interruption se produit et déclenche la conversion ADC, et attend la fin de la conversion
\item La valeur de la conversion est stockée dans le registre TIM4\_ARR, qui est utilisé pour définir la période du timer 4
\end{itemize}
En tant que tel, on peut ensuite utiliser un oscilloscope pour afficher la tension mesurée\\

Nous n'avons pas eu le temps de réfléchir au code, et nous ne savons pas encore si nous préfèrerons le faire en assembleur ou en C

\subsection{Conclusions pour cette séance}
Si nous avons pu prendre en main la carte et réfléchir à l'implémentation du correcteur numériquement, les nombreux freins (problèmes logiciels, logiciels peu ergonomiques...) ont été un frein et nous n'avons pas eu le temps de faire beaucoup de choses. Il sera donc important de travailler entre les deux prochaines séances pour avancer, tant sur la partie analogique, que la partie numérique

\section{Travail entre les séances 2 et 3}
\subsection{Lecture d'une entrée analogique}
Des recherches sur internet nous ont permis de trouver le tutoriel suivant : \href{https://circuitdigest.com/microcontroller-projects/adc-on-stm8s-using-c-compiler-reading-multiple-adc-values-and-displaying-on-lcd}{Tutoriel de CircuitDigest}. Le code fourni permet de lire des entrées analogiques et de les afficher sur un écran LCD. On adapte le code pour que la valeur soit renvoyée dans le moniteur série :

\begin{lstlisting}[language=C]
#include "STM8S.h"
#include "stm8s103_adc.h"
#include "stm8s_uart1.h"

void UART1_Send_Char(char data)
{
    // Attendre que le buffer de transmission soit vide
    while(!(UART1->SR & UART1_SR_TXE));
    // Envoyer le caractere
    UART1->DR = data;
}

void UART1_Send_String(char *str)
{
    while(*str)
    {
        UART1_Send_Char(*str);
        str++;
    }
}

void UART1_Print_Var(int var)
{
    char buffer[6];
    sprintf(buffer, "%d", var);
    UART1_Send_String(buffer);
}

void main()
{
    // Declarations de variables
    unsigned int ADC_value_1 = 0;
    int ADC_voltage_1 = 0;

    CLK_PeripheralClockConfig(CLK_PERIPHERAL_ADC, ENABLE); // Activer l'horloge peripherique pour l'ADC
    GPIO_Init (GPIOC, GPIO_PIN_4, GPIO_MODE_IN_FL_IT);
    
    // Configuration de l'UART
    CLK_PeripheralClockConfig(CLK_PERIPHERAL_UART1, ENABLE);
    UART1_DeInit();
    UART1_Init((uint32_t)9600, UART1_WORDLENGTH_8D, UART1_STOPBITS_1, UART1_PARITY_NO, UART1_SYNCMODE_CLOCK_DISABLE, UART1_MODE_TX_ENABLE);

    delay_ms(5000);

    while (1)
    {
        ADC_value_1 = ADC_Read (AIN2);
        ADC_voltage_1 = ADC_value_1 * (3.226); //(3300/1023 =~ 3.226)convert ADC value 1 to 0 to 3300mV

        UART1_Send_String("D1: ");
        UART1_Print_Var(ADC_value_1);
        UART1_Send_String(" -> ");
        UART1_Print_Var(ADC_voltage_1);
        UART1_Send_String(" mV\r\n");

        UART1_Send_String("\r\n");
        delay_ms(500);
    }
}
\end{lstlisting}

\subsection{Génération d'un signal PWM}
Des recherches sur internet nous ont permis de trouver le tutoriel suivant : \href{https://circuitdigest.com/microcontroller-projects/pulse-width-modulation-pwm-with-stm8-using-cosmic-c-and-stvd}{Tutoriel de CircuitDigest}. On en retire le code suivant :

\begin{lstlisting}[language=C]
#include "STM8S.h"

void delay_ms(int ms) // Function Definition
{
    for (int i = 0; i <= ms; i++)
        for (int j = 0; j < 120; j++) // Nop = Fosc/4
            _asm("nop");              // Perform no operation //assembly code
}

void main(void)
{
    GPIO_DeInit(GPIOD);
    TIM2_DeInit();
    GPIO_Init(GPIOD, GPIO_PIN_4, GPIO_MODE_OUT_PP_HIGH_FAST);
    TIM2_OC1Init(TIM2_OCMODE_PWM1, TIM2_OUTPUTSTATE_ENABLE, 1000, TIM2_OCPOLARITY_HIGH);
    TIM2_TimeBaseInit(TIM2_PRESCALER_1, 500);
    TIM2_Cmd(ENABLE);
    while (TRUE)
    {
        signed int pwm_duty = 500;
        TIM2_SetCompare1(pwm_duty);
    }
}
\end{lstlisting}

Dans la fonction main, les fonctions de configuration et d'initialisation suivantes sont appelées :
\begin{itemize}
\item \lstinline$GPIO_DeInit(GPIOD)$ : réinitialisation des paramètres du port D
\item \lstinline$TIM2_DeInit()$ : réinitialisation du Timer 2
\item \lstinline${GPIO_Init(GPIOD, GPIO_PIN_4, GPIO_MODE_OUT_PP_HIGH_FAST)$ : configuration de la broche PD4 en sortie push-pull avec une vitesse élevée
\item \lstinline$TIM2_OC1Init(...)$ : configuration du Timer 2 pour générer un signal PWM en mode 1 avec un rapport cyclique initial de 1000 (50\%)
\item \lstinline$TIM2_TimeBaseInit(TIM2_PRESCALER_1, 500)$ : configuration de la base de temps du Timer 2 avec un prédiviseur de 1 et une valeur d'autorechargement de 500
\item \lstinline$TIM2_Cmd(ENABLE)$ : activation du Timer 2
\end{itemize}

Enfin, la partie :
\begin{lstlisting}[language=C]
while (TRUE)
    {
        signed int pwm_duty = 500;
        TIM2_SetCompare1(pwm_duty);
    }
\end{lstlisting}
Génère un signal PWM de rapport cyclique \lstinline$pwm_duty$/100

\pagebreak
\section{Bibliographie}
Liste des sites utilisés pour la réalisation du projet :
\begin{itemize}
\item \href{https://www.overleaf.com/learn}{Overleaf, guide d'utilisation du \LaTeX{}}
\item \href{https://chat.openai.com/chat}{ChatGPT, modèle de langage automatisé}
\item \href{https://ctan.mines-albi.fr/graphics/pgf/contrib/circuitikz/doc/circuitikzmanual.pdf}{Manuel de Circuitikz}
\item \href{https://sciences-indus-cpge.papanicola.info/IMG/pdf/schemabloc.pdf}{Manuel des Schéma-blocs avec PGF/TIKZ}
\end{itemize}

\end{document}